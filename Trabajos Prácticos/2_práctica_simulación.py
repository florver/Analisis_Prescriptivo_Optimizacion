# -*- coding: utf-8 -*-
"""2. Práctica Simulación.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15AtxzrHliOjvaDfQGN9eGjj5R2tk45T9

##Link para acceder al código en colab

https://colab.research.google.com/drive/15AtxzrHliOjvaDfQGN9eGjj5R2tk45T9?usp=sharing

# Punto 1

**Realizar una simulación en Python del caso de la panadería visto en clase, pero en
esta ocasión se debe considerar en la operatoria:**
"""

import random
import numpy as np
import simpy
from simpy import Resource

#pip install simpy

random.seed(123)

"""## Simulación

Los eventos que vamos a definir para simular el funcionamiento de la panadería van a ser los siguientes: entrada de los clientes, los recepcionan en el mostrador donde le tomaran la orden, luego se le envia la orden a la cocina. Una vez en la cocina, se realiza el pedido y se entrega al cliente. Luego las cajas reciben al cliente, le cobran y el cliente se retira del local.
"""

data_entrada = []
atencion_mostrador = []
enviar_orden_cocina = []
toma_pedido_cocina = []
cocinar = []
entrega_cocina = []
recibe_cliente_caja = []
cobra_caja = []
retira_cliente = []

def Panaderia(env, name, cant_mostrador, entrada, tiempo_atencion,\
              tiempo_cocina, cant_cocina, tiempo_caja, cant_caja):

     yield env.timeout(entrada)

     # Mostrador
     print('%s Entrada cliente %s' % (name, env.now))
     data_entrada.append(env.now)
     with cant_mostrador.request() as req:
         yield req

         
         print('%s Comienzan a %s atenderlo %s' % (name, env.now, req))
         atencion_mostrador.append(env.now)
         yield env.timeout(tiempo_atencion)
         print('%s Envian la orden a la cocina %s' % (name, env.now))
         enviar_orden_cocina.append(env.now)

     # Cocina
     print('%s Toma el pedido la cocina %s' % (name, env.now))
     toma_pedido_cocina.append(env.now)
     with cant_cocina.request() as req:
         yield req

         
         print('%s Comienzan a cocinarlo %s' % (name, env.now))
         cocinar.append(env.now)
         yield env.timeout(tiempo_cocina)
         print('%s Entregan el pedido %s' % (name, env.now))
         entrega_cocina.append(env.now)

     # Caja
     print('%s Recibe al cliente la caja %s' % (name, env.now))
     recibe_cliente_caja.append(env.now)
     with cant_caja.request() as req:
         yield req

         
         print('%s Cobran al cliente %s' % (name, env.now))
         cobra_caja.append(env.now)
         yield env.timeout(tiempo_caja)
         print('%s Se retira el cliente %s' % (name, env.now))
         retira_cliente.append(env.now)

"""Se le asignan los recursos a cada sector, contando con 3 personas en la atención en el mostrador, 2 personas trabajando en la cocina y 2 cajas cobrando al cliente."""

env = simpy.Environment()
cant_mostrador = simpy.Resource(env, capacity=3)
cant_cocina = simpy.Resource(env, capacity=2)
cant_caja = simpy.Resource(env, capacity=2)

"""Para simular los tiempos en cada instancia vamos a definir las distribuciones. En todas las etapas optamos por samplear una distribucion uniforme. El **ingreso de los clientes** va a tomar darse cada 0 a 5 minutos, considerando como se daba en el problema original donde se esta pensando en una franja horaria frecuentada. El  **mostrador**  va a tardar entre 1 y 5 minutos en tomar el pedido del cliente y enviarlo a la cocina. Una vez en la **cocina** el pedido tardará en ser cocinado y entregado entre 3 y 15 minutos, siendo este el caso que puede tener mayor amplitud en la distribucion ya que depende de la comida que encargue el cliente. Por último, el tiempo que tarda la **caja** en cobrar se distribuye entre 2 y 7 minutos. """

#clientes = np.random.uniform(0,5,3)
#mostrador = np.random.uniform(1,5,1)
#cocina = np.random.uniform(3,15,1)
#caja = np.random.uniform(2,7,1)

cantidad_clientes = 10
for i in range(cantidad_clientes):
     env.process(Panaderia(env, 'Cliente %d' % i, cant_mostrador, \
                           np.random.uniform(1,10,1),np.random.uniform(1,5,1), \
                           np.random.uniform(3,15,1), cant_cocina,\
                           np.random.uniform(2,7,1), cant_caja))

env.run()

"""## Métricas

**- Tiempo de espera promedio para un cliente en cada punto del proceso.**
"""

#Tiempo promedio de espera de un cliente en el mostrador hasta que se le entrega la comida
espera_cocina = []
for i,j in zip(entrega_cocina, data_entrada):
  espera_cocina.append(i - j)
print('El tiempo promedio de espera de un cliente en el mostrador es',\
      (sum(espera_cocina)/len(espera_cocina)))

#Tiempo promedio de espera de un cliente en la caja desde que llega para abonar hasta que se retira
espera_caja = []
for i,j in zip(retira_cliente,recibe_cliente_caja):
  espera_caja.append(i - j)
print('El tiempo promedio de espera de un cliente en la caja es',\
      (sum(espera_caja)/len(espera_caja)))

"""**- Porcentaje de clientes que tuvieron que esperar en el mostrador o en caja.**"""

#Porcentaje de clientes que tuvieron que esperar en el mostrador
#Tiempo de fila en el mostrador hasta ser atendido
espera_cocina = []
for i,j in zip(entrega_cocina, data_entrada):
  espera_cocina.append(i - j)

count = [1 for x in espera_cocina if x>0]

print('El porcentaje de clientes que tuvo que esperar en el mostrador por su comida es',\
      (sum(count)/len(count))*100,'%')

#Porcentaje de clientes que tuvieron que esperar en la caja
#Cambiar y hacer tiempo de fila en la caja
espera_caja = []
for i,j in zip(retira_cliente,recibe_cliente_caja):
  espera_caja.append(i - j)

count = [1 for x in espera_caja if x>0]

print('El porcentaje de clientes que tuvo que esperar en la caja hasta retirarse',\
      (sum(count)/len(count))*100,'%')

"""**- Tiempo promedio del ciclo completo para un cliente**"""

print('El tiempo promedio del ciclo completo de un cliente es',\
      sum(retira_cliente)/len(retira_cliente))

"""**- Tiempo ocioso de cada trabajador**"""

print('El tiempo ocioso total del mostrador fue',\
      (min(data_entrada)-min(atencion_mostrador))+(max(retira_cliente)-max(enviar_orden_cocina)))

print('El tiempo ocioso total de la cocina fue',\
      (min(toma_pedido_cocina)-min(data_entrada))+(max(retira_cliente)-max(entrega_cocina)))

print('El tiempo ocioso total de la caja fue',\
      (min(recibe_cliente_caja)-min(data_entrada))+(max(retira_cliente)-max(cobra_caja)))

"""# Punto 2

**Se tiene una red de caminos entre diferentes puntos que podemos representar
mediante un grafo simple. Dado que no se tiene certeza sobre las distancias en tiempo
que se tarda en atravesar un camino, se quieren realizar simulaciones para encontrar
caminos que tengan una buena esperanza de tiempo de viaje, pero que también
tengan una varianza aceptable.**
"""

import networkx as nx
from networkx.algorithms import bipartite
import random
import numpy as np
import pandas as pd

"""**- Crear una red de al menos 20 vértices, creando también valores asociados a las
aristas para representar un número estimado de minutos que se necesitan para
atravesar cada una de ellas.**
"""

Graph = nx.complete_graph(n = 20)
for (u,v,w) in Graph.edges(data=True):
    w['weight'] = random.randint(2,10)

labels = nx.get_edge_attributes(Graph,'weight')
print(labels)

nx.draw(Graph, with_labels = True)

"""**- Resolver el problema de camino mínimo utilizando directamente los pesos de las
aristas.**
"""

caminos_minimos = nx.shortest_path(Graph, weight="weight")
caminos_minimos

"""**- Definir y justificar distribuciones de tiempos para cada arista basadas en las estimaciones iniciales.**

Para la distribución de tiempos entre las aristas optamos por una distribucion lognormal, dado que es una distribución que se mantiene en valores positivos y también cuenta con la característica de tener colas pesadas. Es decir, que la mayor frecuencia se va a dar entre los primeros valores, pero existe alguna chance, que ante eventos poco probables, el tiempo de demora del viaje alcance valores mucho mas grandes. Esta cualidad nos parecia adecuada para representar el comportamiento del tiempo que se demora en ir de un nodo a otro.
"""

salida = 0
llegada = 15

tiempo_caminos = []
caminos = []

for i in range(100):
  Graph = nx.complete_graph(n = 20)
  for (u,v,w) in Graph.edges(data=True):
      w['weight'] = np.random.lognormal(2, 1.5, 1)
  labels = nx.get_edge_attributes(Graph,'weight')
  min = nx.shortest_path(Graph, weight="weight", source = salida, target = llegada)
  caminos.append(min)
  min_choice = []
  for j in range(len(min)-1): 
    t = labels[j,j+1]
    min_choice.append(t)
  tiempo_caminos.append(sum(min_choice))

tiempo_caminos

print('La media de la distribución de los tiempos es: ',np.mean(tiempo_caminos), ' minutos')
print('El desvío estandar de la distribución de los tiempos es: ',np.std(tiempo_caminos),' minutos')

"""Los posibles mínimos caminos entre el nodo de salida y el de llegada que se seleccionaron, dada la simulación de tiempos anterior, son los siguientes: """

caminos

"""Nos quedamos con los únicos caminos posibles para simular la distribución de tiempos que puede tener cada uno de los ellos y luego, utilizando esta información tomar la decisión de cual sería el más adecuado."""

unicos_caminos = []

for item in caminos: 
    if item not in unicos_caminos: 
        unicos_caminos.append(item)

unicos_caminos

"""**- Utilizar las distribuciones del punto anterior para realizar diversas simulaciones para encontrar el camino mínimo.**"""

dist = []

for h in range(len(unicos_caminos)):
  tiemp_caminos = []
  min = unicos_caminos[h]
  for i in range(100):
    Graph = nx.complete_graph(n = 20)
    for (u,v,w) in Graph.edges(data=True):
        w['weight'] = np.random.lognormal(2, 1.5, 1)
    labels = nx.get_edge_attributes(Graph,'weight')
    min_choice = []
    for j in range(len(min)-1): 
      t = labels[j,j+1]
      min_choice.append(t)
    tiemp_caminos.append(sum(min_choice))
  a = [min, np.mean(tiemp_caminos), np.std(tiemp_caminos)]
  dist.append(a)

dist_caminos = pd.DataFrame(dist, columns = ['Camino', 'Media','Std'])
dist_caminos.sort_values(by=['Media'])
dist_caminos.sort_values(by=['Std'])

"""**- Argumentar qué camino sería finalmente elegido basándose en la esperanza y la varianza de los diferentes caminos.**

Si bien el camino que une directamente los nodos $[0, 15]$ es el que presenta la menor media con *21.5 minutos*, el desvío de este camino es considerable (*52.73 minutos*). Podriamos sugerir como buenos caminos a elegir el que pasa por los nodos $[0, 11 , 15]$ ya que su media no difiere tanto de camino anterior (Media: *31.8 minutos*), pero el desvío es bastante menos con *37.2*.	Otra de las sugerencias podría ser el camino $[0, 13 , 15]$ con una situación similar al anterior mencionado. (Media: *38.9 minutos*, Std: *43.5 minutos*)

# Punto 3

Adjuntamos el documento de Anylogic con la simulación de la rotonda de la ruta 11.
"""
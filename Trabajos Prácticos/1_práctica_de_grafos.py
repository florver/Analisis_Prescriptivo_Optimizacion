# -*- coding: utf-8 -*-
"""1. Práctica de Grafos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G1oHYx6rlnNNJdOdHSAP-GX7nlt7P1mU

##Link para acceder al código en colab

https://colab.research.google.com/drive/1G1oHYx6rlnNNJdOdHSAP-GX7nlt7P1mU?usp=sharing

## Librerias
"""

import networkx as nx
from networkx.algorithms import bipartite
from networkx.algorithms.bipartite import maximum_matching
from networkx.algorithms.bipartite import hopcroft_karp_matching
import numpy as np

"""# Punto 2"""

G = nx.gnp_random_graph(n = 100, p = 0.05)
G

G.nodes

nx.draw_circular(G)

"""# Punto 3"""

A = nx.adjacency_matrix(G)
print(A)

nx.to_numpy_matrix(G)

"""# Punto 4

## a) Grafo Completo
"""

G1 = nx.complete_graph(n = 5)
nx.draw(G1)

"""## b) Grafo bipartito"""

G2 = nx.Graph()
top_nodes = [0, 1]
bottom_nodes = ["A", "B", "C", "D"]
G2.add_nodes_from(top_nodes, bipartite=0)
G2.add_nodes_from(bottom_nodes, bipartite=1)# Add edges with weights
G2.add_edge(0, "A", weight = 1)
G2.add_edge(0, "B", weight = 4)
G2.add_edge(0, "C", weight = 2)
G2.add_edge(0, "D", weight = 1)
G2.add_edge(1, "A", weight = 3)
G2.add_edge(1, "B", weight = 1)
G2.add_edge(1, "C", weight = 2)
G2.add_edge(1, "D", weight = 2)#Obtain the minimum weight full matching

nx.draw_networkx(
    G2,
    pos = nx.drawing.layout.bipartite_layout(G2, top_nodes))

"""## c) Árbol"""

G3 = nx.random_tree(n=10, seed=0)
nx.draw(G3)

"""## d) Grafo Regular"""

G4 = nx.random_regular_graph(d = 5,n = 10)
nx.draw(G4)

"""## e) Grafo ciclo"""

G5 = nx.cycle_graph(n = 9)
nx.draw(G5)

"""## f) Grafo camino"""

edges6 = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]
G6 = nx.DiGraph(edges6)
nx.draw(G6)

"""## g) Grafo intervalos"""

intervalos = [(-2, 3), [0, 4], (2, 3), (4, 6)]
G7 = nx.interval_graph(intervalos)
sorted(G7.edges)
color = ["red","blue","yellow","green"]
nx.draw(G7, with_labels = True, node_color = color)

import matplotlib.pyplot as plt

X1 = [-2,3]
Y1 = [0, 0]
X2 = [1,4]
Y2 = [1, 1]
X3 = [2,3]
Y3 = [2, 2]
X4 = [4,6]
Y4 = [3, 3]

plt.plot(X1,Y1,"red")
plt.plot(X2,Y2,"blue")
plt.plot(X3,Y3,"yellow")
plt.plot(X4,Y4,"green")

"""# Punto 5"""

def metricas(G):
  diametro = nx.diameter(G)
  radio = nx.radius(G)
  centro = nx.center(G)
  componente = nx.number_connected_components(G)
  print("El diametro es ", diametro )
  print("El radio es ", radio )
  print("El vertice central es ", centro )
  print("La cantidad de componentes conexas es ", componente )

metricas(G1)

metricas(G2)

metricas(G3)

metricas(G4)

metricas(G5)

metricas(G6)

metricas(G7)

"""# Punto 6"""

#list(nx.dfs_tree(G6,source=0).edges())
#list(nx.bfs_tree(G6,source=0).edges())
#list(nx.tree.minimum_spanning_edges(G6, algorithm="kruskal", data=False))
#nx.shortest_path(G6)

def recorridos(G):
  if G == G7: 
    s = (-2,3)
  else : 
    s=0
  DFS = list(nx.dfs_tree(G,source=s).edges())
  BFS = list(nx.bfs_tree(G,source=s).edges())
  MST = list(nx.tree.minimum_spanning_edges(G, algorithm="kruskal", data=False))
  caminos_minimos = nx.shortest_path(G)
  print("El DFS es ", DFS )
  print("El BFS es ", BFS )
  print("El MST es ", MST )
  print("Los caminos minimos de a pares son: ", caminos_minimos )

recorridos(G1)

recorridos(G2)

recorridos(G3)

recorridos(G4)

recorridos(G5)

recorridos(G6)

recorridos(G7)

"""# Punto 7

**Se tiene un tablero de ajedrez de NxN con algunas casillas inutilizables y se quieren colocar la mayor cantidad posibles de torres de tal manera que no se ataquen entre sí (una torre ataca toda la fila y columna en la que se encuentra presente). Resolver el problema utilizando el problema de Maximum Flow**

Considerando que si coloco una torre, se toman toda una fila y la columna correspondiente. Podemos pensar en una representacion mediante  un *Grafo Bipartido* donde de un lado los nodos representan las filas y por el otro tenemos las columnas. 
Cada combinacion de fila/columna puede darse para colocar la torre siempre y cuando no este ocupada la casilla por otra pieza. 
Dada un probabilidad de conexion de un 20% entre filas y columnas podemos pensar a un tablero de la siguiente manera:
"""

RB = bipartite.random_graph(10, 10, 0.2, directed = False)
RB_top = {n for n, d in RB.nodes(data=True) if d["bipartite"] == 0}
RB_bottom = set(RB) - RB_top

nx.draw_networkx(RB,pos = nx.drawing.layout.bipartite_layout(RB, RB_top))

RB.add_node('salida')
RB.add_node('llegada')

RB.add_edge('salida', 0, capacity= 1)
RB.add_edge('salida', 1, capacity= 1)
RB.add_edge('salida', 2, capacity= 1)
RB.add_edge('salida', 3, capacity= 1)
RB.add_edge('salida', 4, capacity= 1)
RB.add_edge('salida', 5, capacity= 1)
RB.add_edge('salida', 6, capacity= 1)
RB.add_edge('salida', 7, capacity= 1)
RB.add_edge('salida', 8, capacity= 1)
RB.add_edge('salida', 9, capacity= 1)

RB.add_edge(10, 'llegada', capacity= 1)
RB.add_edge(11, 'llegada', capacity= 1)
RB.add_edge(12, 'llegada', capacity= 1)
RB.add_edge(13, 'llegada', capacity= 1)
RB.add_edge(14, 'llegada', capacity= 1)
RB.add_edge(15, 'llegada', capacity= 1)
RB.add_edge(16, 'llegada', capacity= 1)
RB.add_edge(17, 'llegada', capacity= 1)
RB.add_edge(18, 'llegada', capacity= 1)

nx.draw_networkx(RB,pos = nx.drawing.layout.bipartite_layout(RB, RB_top))

"""Ahora para saber cual es la mayor cantidad posibles de torres que podria colocar dado un tablero, vamos a resolver Maximum Flow para conocer todas las posibles conexiones, y luego, conocer como se tienen que dar esas combinaciones de manera que yo coloque la mayor cantidad de torres."""

nx.maximum_flow(RB,"salida", "llegada")

nx.algorithms.bipartite.maximum_matching(RB)

print('La mayor cantidad de torres que voy a poder colocar va a estar dada por: ',\
      (len(nx.algorithms.bipartite.maximum_matching(RB))/2)-2)